<h1>Results</h1>

<h3> Test case 1: </h3>

For the default problem the value of u on Gamma is 1: this is like imposing a constant
Dirichlet boundary on the portion of $\Omega$ inside gamma.
<p align="center">
  <img src="https://www.dealii.org/images/steps/developer/step-60_1_no_grid.png" alt=""
   style="width: 50%; height: 50%">
</p>
In this second image we can appreciate how, using GridTools::compute_point_locations ,
we have been able to adaptively refine $\Omega$ exactly where the solution is varying
the most:

<p align="center">
  <img src="https://www.dealii.org/images/steps/developer/step-60_1_grid.png" alt=""
   style="width: 50%; height: 50%">
</p>

<a name="extensions"></a>
<h3>Possibilities for extensions</h3>

Add something

<h4> Parallel Code </h4>

The simple code proposed here can serve as a starting point for more
complex problems which, to be solved, need to be run on parallel
code, possibly using distributed meshes (see step-17, step-40, and the
documentation for parallel::shared::Triangulation and
parallel::distributed::Triangulation ).

When using non-matching grids in parallel a problem arises:
to compute the matrix $C$ a process needs information about both
meshes on the same portion of real space but, when working with
distributed meshes, this might not be the case.
Various strategies can be implemented to tackle this problem:

- distribute the two meshes so that this constraint is satisfied
- use communication for the parts of real space where the constraint is
 not satisfied
- make use of a shared triangulation and a distributed triangulation

The latter strategy is clearly the easier to implement, as all
the function used in this tutorial program can work letting $\Omega$
be distributed and $\Gamma$ be a shared triangulation.
